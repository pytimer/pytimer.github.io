

  
    
  


  





  

<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.53 with theme Tranquilpeak 0.4.3-BETA">
    <title>Docker容器无法连接外部网络原因排查</title>
    <meta name="author" content="Pytimer">
    <meta name="keywords" content="">

    <link rel="icon" href="https://pytimer.github.io/favicon.png">
    

    
    <meta name="description" content="Docker是当前最常用的容器运行时引擎，在使用Kubernetes的过程中，我们使用Docker来负责底层的容器的启动、停止。在用户新安装Docker后的使用过程中，发现通过docker run命令启动的容器，使用默认的bridge网络的情况下，容器无法连接到外部网络，针对这个现象进行排查。
缩小问题范围 使用 docker run -it --rm alpine:3.6 /bin/sh 启动一个容器，采用bridge网络，在容器内ping外部网络的IP，我们发现是无法ping通，该命令会hang住。退出该容器，再尝试使用host网络启动容器，docker run -it --rm --network=host alpine:3.6 /bin/sh，这次我们发现是可以ping通外部网络的，说明是docker的默认bridge网络有问题，缩小范围。
容器使用bridge网络的情况下，在ping外部网络的情况下，如果发送的不是Docker启动创建的docker0的网桥，会进行SNAT，然后使用宿主机的网卡出去，那么怀疑是SNAT可能有问题，因此查看iptables中和Docker相关的规则。命令结果如下：
# iptables -t nat -nvL POSTROUTING Chain POSTROUTING (policy ACCEPT 845 packets, 57086 bytes) pkts bytes target prot opt in out source destination 1414 96107 POSTROUTING_direct all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES_SOURCE all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES all -- * * 0.0.0.0/0 0.0.0.0/0  根据上面结果，我们发现缺少了一条-A POSTROUTING -s 172.">
    <meta property="og:description" content="Docker是当前最常用的容器运行时引擎，在使用Kubernetes的过程中，我们使用Docker来负责底层的容器的启动、停止。在用户新安装Docker后的使用过程中，发现通过docker run命令启动的容器，使用默认的bridge网络的情况下，容器无法连接到外部网络，针对这个现象进行排查。
缩小问题范围 使用 docker run -it --rm alpine:3.6 /bin/sh 启动一个容器，采用bridge网络，在容器内ping外部网络的IP，我们发现是无法ping通，该命令会hang住。退出该容器，再尝试使用host网络启动容器，docker run -it --rm --network=host alpine:3.6 /bin/sh，这次我们发现是可以ping通外部网络的，说明是docker的默认bridge网络有问题，缩小范围。
容器使用bridge网络的情况下，在ping外部网络的情况下，如果发送的不是Docker启动创建的docker0的网桥，会进行SNAT，然后使用宿主机的网卡出去，那么怀疑是SNAT可能有问题，因此查看iptables中和Docker相关的规则。命令结果如下：
# iptables -t nat -nvL POSTROUTING Chain POSTROUTING (policy ACCEPT 845 packets, 57086 bytes) pkts bytes target prot opt in out source destination 1414 96107 POSTROUTING_direct all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES_SOURCE all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES all -- * * 0.0.0.0/0 0.0.0.0/0  根据上面结果，我们发现缺少了一条-A POSTROUTING -s 172.">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="Docker容器无法连接外部网络原因排查">
    <meta property="og:url" content="/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
    <meta property="og:site_name" content="Pytimer Blog">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Pytimer Blog">
    <meta name="twitter:description" content="Docker是当前最常用的容器运行时引擎，在使用Kubernetes的过程中，我们使用Docker来负责底层的容器的启动、停止。在用户新安装Docker后的使用过程中，发现通过docker run命令启动的容器，使用默认的bridge网络的情况下，容器无法连接到外部网络，针对这个现象进行排查。
缩小问题范围 使用 docker run -it --rm alpine:3.6 /bin/sh 启动一个容器，采用bridge网络，在容器内ping外部网络的IP，我们发现是无法ping通，该命令会hang住。退出该容器，再尝试使用host网络启动容器，docker run -it --rm --network=host alpine:3.6 /bin/sh，这次我们发现是可以ping通外部网络的，说明是docker的默认bridge网络有问题，缩小范围。
容器使用bridge网络的情况下，在ping外部网络的情况下，如果发送的不是Docker启动创建的docker0的网桥，会进行SNAT，然后使用宿主机的网卡出去，那么怀疑是SNAT可能有问题，因此查看iptables中和Docker相关的规则。命令结果如下：
# iptables -t nat -nvL POSTROUTING Chain POSTROUTING (policy ACCEPT 845 packets, 57086 bytes) pkts bytes target prot opt in out source destination 1414 96107 POSTROUTING_direct all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES_SOURCE all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES all -- * * 0.0.0.0/0 0.0.0.0/0  根据上面结果，我们发现缺少了一条-A POSTROUTING -s 172.">
    
    

    
    

    
      <meta property="og:image" content="https://raw.githubusercontent.com/pytimer/pytimer.github.io/master/gopher.png">
    

    
    
    

    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://pytimer.github.io/css/style-jsjn0006wyhpyzivf6yceb31gvpjatbcs3qzjvlumobfnugccvobqwxnnaj8.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="4">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://pytimer.github.io/">Pytimer Blog</a>
  </div>
  
    
      <a class="header-right-icon open-algolia-search"
         href="https://pytimer.github.io/#search">
    
    
      <i class="fa fa-lg fa-search"></i>
    
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="4">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://pytimer.github.io/#about">
          <img class="sidebar-profile-picture" src="https://raw.githubusercontent.com/pytimer/pytimer.github.io/master/gopher.png" alt="作者的图片" />
        </a>
        <h4 class="sidebar-profile-name">Pytimer</h4>
        
          <h5 class="sidebar-profile-bio">Software Develper, <strong>Like Go and Cloud</strong></h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://pytimer.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">首页</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://pytimer.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">分类</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://pytimer.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">标签</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://pytimer.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">归档</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/pytimer" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="4"
        class="
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      Docker容器无法连接外部网络原因排查
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-11-20T11:08:41&#43;08:00">
        
  
  
  
  
    20 十一月 2019
  

      </time>
    
    
  
  
    <span>发布在</span>
    
      <a class="category-link" href="https://pytimer.github.io/categories/docker">Docker</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>Docker是当前最常用的容器运行时引擎，在使用Kubernetes的过程中，我们使用Docker来负责底层的容器的启动、停止。在用户新安装Docker后的使用过程中，发现通过<code>docker run</code>命令启动的容器，使用默认的bridge网络的情况下，容器无法连接到外部网络，针对这个现象进行排查。</p>

<h2 id="缩小问题范围">缩小问题范围</h2>

<p>使用 <code>docker run -it --rm alpine:3.6 /bin/sh</code> 启动一个容器，采用bridge网络，在容器内<code>ping</code>外部网络的IP，我们发现是无法ping通，该命令会hang住。退出该容器，再尝试使用host网络启动容器，<code>docker run -it --rm --network=host alpine:3.6 /bin/sh</code>，这次我们发现是可以<code>ping</code>通外部网络的，说明是docker的默认bridge网络有问题，缩小范围。</p>

<p>容器使用bridge网络的情况下，在<code>ping</code>外部网络的情况下，如果发送的不是Docker启动创建的<code>docker0</code>的网桥，会进行SNAT，然后使用宿主机的网卡出去，那么怀疑是SNAT可能有问题，因此查看iptables中和Docker相关的规则。命令结果如下：</p>

<pre><code class="language-sh"># iptables -t nat -nvL POSTROUTING
Chain POSTROUTING (policy ACCEPT 845 packets, 57086 bytes)
 pkts bytes target     prot opt in     out     source               destination
 1414 96107 POSTROUTING_direct  all  --  *      *       0.0.0.0/0            0.0.0.0/0
 1414 96107 POSTROUTING_ZONES_SOURCE  all  --  *      *       0.0.0.0/0            0.0.0.0/0
 1414 96107 POSTROUTING_ZONES  all  --  *      *       0.0.0.0/0            0.0.0.0/0
</code></pre>

<p>根据上面结果，我们发现缺少了一条<code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code>的iptables规则。我们怀疑是用户在配置Docker的时候，配置出错导致的该问题。</p>

<h2 id="排查过程">排查过程</h2>

<p>根据上面的章节，我们发现是iptable的SNAT规则有问题，那么我们就要看Docker是如何来生成该规则的。</p>

<h3 id="查看配置">查看配置</h3>

<p>首先查看官方的<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#run-multiple-daemons">文档</a>，我们看到官方文档有一段关于SNAT的相关配置：</p>

<blockquote>
<p><code>--iptables=false</code> prevents the Docker daemon from adding iptables rules. If multiple daemons manage iptables rules, they may overwrite rules set by another daemon. Be aware that disabling this option requires you to manually add iptables rules to expose container ports. If you prevent Docker from adding iptables rules, Docker will also not add IP masquerading rules, even if you set <code>--ip-masq</code> to <code>true</code>. Without IP masquerading rules, Docker containers will not be able to connect to external hosts or the internet when using network other than default bridge.</p>
</blockquote>

<p>可以看到对于缺少的这条规则来说，需要dockerd在启动的时候有两项配置<code>--iptables=true</code>和<code>--ip-masq=true</code>，否则Docker不会在创建默认网桥的时候生成该规则，从而容器无法访问外部网络，但是Docker默认以上两个配置项默认均为<code>true</code>。我们让用户登录出现该问题的机器上，查看<code>/etc/docker/daemon.json</code>里的上述两项配置，发现确实是因为设置了<code>--ip-masq=false</code>，这个配置是我们在Kubernetes的环境上开启的，用户在新安装的时候，由于不清楚Docker的相关配置，直接拷贝了Kubernetes环境上的配置，导致覆盖了Docker默认的配置，从而出现了容器内部无法访问外部网络的情况。</p>

<p>到这里问题已经排查清楚，下面我们看下<code>dockerd</code>是如何根据<code>--ip-masq</code>这个参数生成<code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code>这条iptables规则的。</p>

<h3 id="查看日志">查看日志</h3>

<p>我们把<code>dockerd</code>的debug模式开启，在<code>--ip-masq</code>为<code>false</code>的情况下，我们重启<code>dockerd</code>的服务，看到日志如下：</p>

<p><details>
<summary>未启用<code>ip-masq</code>的dockerd启动日志</summary>
<pre><blockcode>
Nov 18 10:36:25 localhost systemd[1]: Starting Docker Application Container Engine&hellip;
&ndash; Subject: Unit docker.service has begun start-up
&ndash; Defined-By: systemd</p>

<h2 id="support-http-lists-freedesktop-org-mailman-listinfo-systemd-devel">&ndash; Support: <a href="http://lists.freedesktop.org/mailman/listinfo/systemd-devel">http://lists.freedesktop.org/mailman/listinfo/systemd-devel</a></h2>

<p>&ndash; Unit docker.service has begun starting up.
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.645346653+08:00&rdquo; level=debug msg=&ldquo;Listener created for HTTP on unix (/var/run/docker.sock)&rdquo;
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.703480025+08:00&rdquo; level=warning msg=&ldquo;libcontainerd: could not upgrade state files during live restore for container b4d6a03f5d78537aed03e54307a3074f8c7c9fe4b8b60618c4c61abfe897ea06: json: cannot unmarshal number into Go struct field State.init_process_start of type string&rdquo;
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.824283436+08:00&rdquo; level=warning msg=&ldquo;libcontainerd: could not upgrade state files during live restore for container 2af4603ecccde03ace1e0c652f6cda75adba1502b729db50bb15de92f75c7021: json: cannot unmarshal number into Go struct field State.init_process_start of type string&rdquo;
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.852366488+08:00&rdquo; level=info msg=&ldquo;libcontainerd: new containerd process, pid: 12468&rdquo;
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.884451175+08:00&rdquo; level=debug msg=&ldquo;containerd: grpc api on /var/run/docker/libcontainerd/docker-containerd.sock&rdquo;
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.891178698+08:00&rdquo; level=debug msg=&ldquo;containerd: read past events&rdquo; count=624
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.895318127+08:00&rdquo; level=debug msg=&ldquo;containerd: container restored&rdquo; id=00ea5e25d0e3f815e37d54dac5286b1c4c85c97457a9a159a2819e603d38ba38
Nov 18 10:36:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:25.896635095+08:00&rdquo; level=debug msg=&ldquo;containerd: container restored&rdquo; id=01f7de8633244f2ed7094a706141e714a1e9a745d317a3389e7d73a6498bfd3e
Nov 18 10:36:26 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:26.311542843+08:00&rdquo; level=debug msg=&ldquo;containerd: supervisor running&rdquo; cpus=10 memory=15884 runtime=docker-runc runtimeArgs=[] stateDir=&ldquo;/var/run/docker/libcontainerd/containerd&rdquo;
id=b4d6a03f5d78537aed03e54307a3074f8c7c9fe4b8b60618c4c61abfe897ea06 pid=init status=1 systemPid=9915
Nov 18 10:36:26 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:26.75219215+08:00&rdquo; level=debug msg=&ldquo;truncating event log&rdquo;
Nov 18 10:36:26 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:26.885192866+08:00&rdquo; level=debug msg=&ldquo;Using default logging driver json-file&rdquo;
Nov 18 10:36:26 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:26.885394029+08:00&rdquo; level=debug msg=&ldquo;Golang&rsquo;s threads limit set to 114120&rdquo;
Nov 18 10:36:27 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:27.037816649+08:00&rdquo; level=info msg=&rdquo;[graphdriver] using prior storage driver: overlay&rdquo;
Nov 18 10:36:27 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:27.037886696+08:00&rdquo; level=debug msg=&ldquo;Using graph driver overlay&rdquo;
Nov 18 10:36:47 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:47.231452175+08:00&rdquo; level=debug msg=&ldquo;Max Concurrent Downloads: 3&rdquo;
Nov 18 10:36:47 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:47.231546307+08:00&rdquo; level=debug msg=&ldquo;Max Concurrent Uploads: 5&rdquo;
Nov 18 10:36:47 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:47.765935586+08:00&rdquo; level=info msg=&ldquo;Graph migration to content-addressability took 0.00 seconds&rdquo;
Nov 18 10:36:47 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:47.767705404+08:00&rdquo; level=info msg=&ldquo;Loading containers: start.&rdquo;
Nov 18 10:36:48 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:36:48.127053639+08:00&rdquo; level=debug msg=&ldquo;Loaded container 00ea5e25d0e3f815e37d54dac5286b1c4c85c97457a9a159a2819e603d38ba38&rdquo;
&hellip;
Nov 18 10:37:02 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:02.537544686+08:00&rdquo; level=debug msg=&ldquo;libcontainerd: restore container d3675c3093e6d9798a1f0d4ac1adf701e14ae5c576838b1922cc287b23643369 state running&rdquo;
Nov 18 10:37:24 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:24.872529481+08:00&rdquo; level=debug msg=&ldquo;Option Experimental: false&rdquo;
Nov 18 10:37:24 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:24.872623250+08:00&rdquo; level=debug msg=&ldquo;Option DefaultDriver: bridge&rdquo;
Nov 18 10:37:24 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:24.872645419+08:00&rdquo; level=debug msg=&ldquo;Option DefaultNetwork: bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.137877612+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.154943092+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D OUTPUT -m addrtype &ndash;dst-type LOCAL ! &ndash;dst 127.0.0.0/8 -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.170953079+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.185271347+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D PREROUTING]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.198304019+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D OUTPUT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.212138653+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -F DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.226024377+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -X DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.240471905+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -F DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.260903009+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -X DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.277556321+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -F DOCKER-ISOLATION]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.296239533+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -X DOCKER-ISOLATION]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.309454170+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -n -L DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.319968029+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -N DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.330245091+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -n -L DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.342196683+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -n -L DOCKER-ISOLATION]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.356755687+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C DOCKER-ISOLATION -j RETURN]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.371465691+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -A DOCKER-ISOLATION -j RETURN]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.475654176+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -i docker0 -o docker0 -j DROP]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.492682638+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 -o docker0 -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.506983374+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 ! -o docker0 -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.522621189+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.535000682+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -A PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.548194608+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER ! &ndash;dst 127.0.0.0/8]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.559555080+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -A OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER ! &ndash;dst 127.0.0.0/8]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.573701209+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.587198568+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.599839612+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.612769657+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.628283870+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.643898371+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.661793237+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.682111845+08:00&rdquo; level=debug msg=&ldquo;Network (aa8157c) restored&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.685520213+08:00&rdquo; level=debug msg=&ldquo;Endpoint (2a75234) restored to network (aa8157c)&rdquo;
<span style="background:yellow;">Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.686140799+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C DOCKER -p tcp -d 0/0 &ndash;dport 8031 -j DNAT &ndash;to-destination 172.17.0.5:8031 ! -i docker0]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.728470794+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -A DOCKER -p tcp -d 0/0 &ndash;dport 8031 -j DNAT &ndash;to-destination 172.17.0.5:8031 ! -i docker0]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.743250375+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.5 &ndash;dport 8031 -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.761040207+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.5 &ndash;dport 8031 -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.781458609+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C POSTROUTING -p tcp -s 172.17.0.5 -d 172.17.0.5 &ndash;dport 8031 -j MASQUERADE]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.817543904+08:00&rdquo; level=debug msg=&ldquo;Endpoint (9c4b929) restored to network (aa8157c)&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.817645126+08:00&rdquo; level=debug msg=&ldquo;Endpoint (ca32793) restored to network (aa8157c)&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.817965521+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C DOCKER -p tcp -d 0/0 &ndash;dport 8200 -j DNAT &ndash;to-destination 172.17.0.6:8500 ! -i docker0]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.835336546+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -A DOCKER -p tcp -d 0/0 &ndash;dport 8200 -j DNAT &ndash;to-destination 172.17.0.6:8500 ! -i docker0]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.852558621+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.6 &ndash;dport 8500 -j ACCEPT]&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.870653385+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.6 &ndash;dport 8500 -j ACCEPT]&rdquo;</span>
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.919703349+08:00&rdquo; level=debug msg=&ldquo;Endpoint (e532036) restored to network (aa8157c)&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.919785071+08:00&rdquo; level=debug msg=&ldquo;Endpoint (08d870c) restored to network (aa8157c)&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.970019076+08:00&rdquo; level=debug msg=&ldquo;Allocating IPv4 pools for network bridge (aa8157c4bbf581e542fcfb6d0c1291b17b0d8b70d0ce3fd92830a9dfdf69877b)&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.970079737+08:00&rdquo; level=debug msg=&ldquo;RequestPool(LocalDefault, 172.17.0.0/16, , map[], false)&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.970245816+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.1, map[RequestAddressType:com.docker.network.gateway])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974256136+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint elastic_hypatia&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974354929+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.2, map[])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974428765+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint heuristic_lovelace&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974458297+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.3, map[])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974498116+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint zen_montalcini&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974529968+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.9, map[])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974567495+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint sharp_yalow&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974593215+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.5, map[])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974634826+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint agitated_ardinghelli&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974660075+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.8, map[])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974690759+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint consul_tttt&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974773988+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.7, map[])&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974803107+08:00&rdquo; level=debug msg=&ldquo;Assigning addresses for endpoint happy_gates&rsquo;s interface on network bridge&rdquo;
Nov 18 10:37:25 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:25.974829205+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.4, map[])&rdquo;
Nov 18 10:37:33 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:33.275111037+08:00&rdquo; level=info msg=&ldquo;There are old running containers, the network config will not take affect&rdquo;
Nov 18 10:37:43 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:43.537678207+08:00&rdquo; level=info msg=&ldquo;Loading containers: done.&rdquo;
Nov 18 10:37:43 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:43.877029545+08:00&rdquo; level=info msg=&ldquo;Daemon has completed initialization&rdquo;
Nov 18 10:37:43 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:43.877112287+08:00&rdquo; level=info msg=&ldquo;Docker daemon&rdquo; commit=cec0b72 graphdriver=overlay version=17.06.2-ce
Nov 18 10:37:43 localhost dockerd[12450]: time=&ldquo;2019-11-18T10:37:43.877314877+08:00&rdquo; level=debug msg=&ldquo;Registering routers&rdquo;
</blockcode></pre>
</details></p>

<p>通过dockerd的启动日志，看到没有关于设置<code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code>的。接着看下在<code>--ip-masq</code>为<code>true</code>的情况下，<code>dockerd</code>服务的日志：</p>

<p><details>
<summary>启用<code>ip-masq</code>的dockerd日志</summary>
<pre><blockcode>
Nov 20 19:56:25 localhost systemd[1]: Starting Docker Application Container Engine&hellip;
&ndash; Subject: Unit docker.service has begun start-up
&ndash; Defined-By: systemd</p>

<h2 id="support-http-lists-freedesktop-org-mailman-listinfo-systemd-devel-1">&ndash; Support: <a href="http://lists.freedesktop.org/mailman/listinfo/systemd-devel">http://lists.freedesktop.org/mailman/listinfo/systemd-devel</a></h2>

<p>&ndash; Unit docker.service has begun starting up.
Nov 20 19:56:25 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:25.360829851+08:00&rdquo; level=debug msg=&ldquo;Listener created for HTTP on unix (/var/run/docker.sock)&rdquo;
Nov 20 19:56:25 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:25.363662244+08:00&rdquo; level=info msg=&ldquo;libcontainerd: new containerd process, pid: 29205&rdquo;
Nov 20 19:56:25 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:25.413798954+08:00&rdquo; level=debug msg=&ldquo;containerd: grpc api on /var/run/docker/libcontainerd/docker-containerd.sock&rdquo;
Nov 20 19:56:25 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:25.43069298+08:00&rdquo; level=debug msg=&ldquo;containerd: read past events&rdquo; count=889
Nov 20 19:56:25 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:25.431920253+08:00&rdquo; level=debug msg=&ldquo;containerd: supervisor running&rdquo; cpus=10 memory=15884 runtime=docker-runc runtimeArgs=[] stateDir=&ldquo;/var/run/docker/libcontainerd/containerd&rdquo;
Nov 20 19:56:26 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:26.367814654+08:00&rdquo; level=debug msg=&ldquo;Using default logging driver json-file&rdquo;
Nov 20 19:56:26 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:26.367968513+08:00&rdquo; level=debug msg=&ldquo;Golang&rsquo;s threads limit set to 114120&rdquo;
Nov 20 19:56:26 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:26.482988509+08:00&rdquo; level=info msg=&rdquo;[graphdriver] using prior storage driver: overlay&rdquo;
Nov 20 19:56:26 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:26.483074356+08:00&rdquo; level=debug msg=&ldquo;Using graph driver overlay&rdquo;
Nov 20 19:56:27 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:27.012441762+08:00&rdquo; level=debug msg=&ldquo;Max Concurrent Downloads: 3&rdquo;
Nov 20 19:56:27 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:27.012511378+08:00&rdquo; level=debug msg=&ldquo;Max Concurrent Uploads: 5&rdquo;
Nov 20 19:56:27 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:27.978489276+08:00&rdquo; level=info msg=&ldquo;Graph migration to content-addressability took 0.00 seconds&rdquo;
Nov 20 19:56:27 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:27.981563636+08:00&rdquo; level=info msg=&ldquo;Loading containers: start.&rdquo;
Nov 20 19:56:27 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:27.998301236+08:00&rdquo; level=debug msg=&ldquo;Loaded container 0019277d551acd628a2a261700084b140f4eb5200d325224f9939c7d8b369210&rdquo;
&hellip;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.733974785+08:00&rdquo; level=debug msg=&ldquo;Option Experimental: false&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.734076895+08:00&rdquo; level=debug msg=&ldquo;Option DefaultDriver: bridge&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.734109116+08:00&rdquo; level=debug msg=&ldquo;Option DefaultNetwork: bridge&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.845959144+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.874553702+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D OUTPUT -m addrtype &ndash;dst-type LOCAL ! &ndash;dst 127.0.0.0/8 -j DOCKER]&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.901055240+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.922319105+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D PREROUTING]&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.944060777+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D OUTPUT]&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.967324383+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -F DOCKER]&rdquo;
Nov 20 19:56:55 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:55.987413083+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -X DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.014868917+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -F DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.036961301+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -X DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.055275108+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -F DOCKER-ISOLATION]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.074053719+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -X DOCKER-ISOLATION]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.090371208+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -n -L DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.108678619+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -N DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.131947559+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -n -L DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.148991887+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -n -L DOCKER-ISOLATION]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.164710366+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C DOCKER-ISOLATION -j RETURN]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.181511594+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -A DOCKER-ISOLATION -j RETURN]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.284105227+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.308756270+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C DOCKER -i docker0 -j RETURN]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.335641210+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -I DOCKER -i docker0 -j RETURN]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.363230612+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -i docker0 -o docker0 -j DROP]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.383616696+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.402559510+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 ! -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.421681542+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.443809710+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -A PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.468883034+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER ! &ndash;dst 127.0.0.0/8]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.490892976+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -A OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER ! &ndash;dst 127.0.0.0/8]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.516061320+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.535614080+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.554691848+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.575195396+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.594073056+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.612002882+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.633447313+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.656813751+08:00&rdquo; level=debug msg=&ldquo;Network (a1a0658) restored&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.696105374+08:00&rdquo; level=debug msg=&ldquo;Allocating IPv4 pools for network bridge (a1a065871eb32a252c404df0612daa76062e75d30d19f168a3964da23c637b39)&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.696189927+08:00&rdquo; level=debug msg=&ldquo;RequestPool(LocalDefault, 172.17.0.0/16, , map[], false)&rdquo;
Nov 20 19:56:56 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:56.696395058+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.1, map[RequestAddressType:com.docker.network.gateway])&rdquo;
Nov 20 19:56:57 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:57.128664833+08:00&rdquo; level=info msg=&ldquo;Removing stale sandbox c2652096fb8d27c58a0f43b2a81290cc04606ff6a8ae9fb12020991bcc159e45 (a206fe6accc38d656cf33e31bde6390dfcb94a7d57d7be0f4f3580377cfec219)&rdquo;
Nov 20 19:56:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:56:58.015474182+08:00&rdquo; level=error msg=&ldquo;getEndpointFromStore for eid efdaba4bad3c4609bf9e121658cb8e41fc2f1e3830449e6fe43bc54cc8d336d8 failed while trying to build sandbox for cleanup: could not find endpoint efdaba4bad3c4609bf9e121658cb8e41fc2f1e3830449e6fe43bc54cc8d336d8: []&rdquo;
&hellip;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.206143067+08:00&rdquo; level=info msg=&ldquo;Fixing inconsistent endpoint_cnt for network none. Expected=0, Actual=4&rdquo;
<span style="background:yellow;">Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.284957847+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.305198036+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE]&rdquo;</span>
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.327371741+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C DOCKER -i docker0 -j RETURN]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.346494574+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -D DOCKER -i docker0 -j RETURN]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.369452177+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.385374448+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -i docker0 -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.403740178+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 ! -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.420012781+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -i docker0 ! -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.437025163+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.451082839+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.465296414+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.481200659+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.497479356+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.513781726+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.585051073+08:00&rdquo; level=debug msg=&ldquo;releasing IPv4 pools from network bridge (a1a065871eb32a252c404df0612daa76062e75d30d19f168a3964da23c637b39)&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.585130601+08:00&rdquo; level=debug msg=&ldquo;ReleaseAddress(LocalDefault/172.17.0.0/16, 172.17.0.1)&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.585188268+08:00&rdquo; level=debug msg=&ldquo;ReleasePool(LocalDefault/172.17.0.0/16)&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.618285456+08:00&rdquo; level=debug msg=&ldquo;cleanupServiceBindings for a1a065871eb32a252c404df0612daa76062e75d30d19f168a3964da23c637b39&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.689639084+08:00&rdquo; level=info msg=&ldquo;Default bridge (docker0) is assigned with an IP address 172.17.0.0/16. Daemon option &ndash;bip can be used to set a preferred IP address&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.689744084+08:00&rdquo; level=debug msg=&ldquo;Allocating IPv4 pools for network bridge (8d788c8c16ae53e5afc4b42e85f37bf6d90a534d4a912a0e526c1fee9eb372e7)&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.689771299+08:00&rdquo; level=debug msg=&ldquo;RequestPool(LocalDefault, 172.17.0.0/16, , map[], false)&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.689858293+08:00&rdquo; level=debug msg=&ldquo;RequestAddress(LocalDefault/172.17.0.0/16, 172.17.0.1, map[RequestAddressType:com.docker.network.gateway])&rdquo;
<span style="background:yellow;">Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.690245805+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.706716889+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -I POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE]&rdquo;</span>
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.730492852+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C DOCKER -i docker0 -j RETURN]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.751247682+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -I DOCKER -i docker0 -j RETURN]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.774815794+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -i docker0 -o docker0 -j DROP]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.790259210+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.807369393+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -i docker0 -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.826121363+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -i docker0 ! -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.846859743+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -i docker0 ! -o docker0 -j ACCEPT]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.867987977+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.887877305+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C PREROUTING -m addrtype &ndash;dst-type LOCAL -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.908672750+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER ! &ndash;dst 127.0.0.0/8]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.927645010+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t nat -C OUTPUT -m addrtype &ndash;dst-type LOCAL -j DOCKER ! &ndash;dst 127.0.0.0/8]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.950293283+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.968980254+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -o docker0 -j DOCKER]&rdquo;
Nov 20 19:57:58 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:58.987675944+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.003987393+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -o docker0 -m conntrack &ndash;ctstate RELATED,ESTABLISHED -j ACCEPT]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.022481990+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.039402584+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.058339359+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -j DOCKER-ISOLATION]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.139123493+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -n -L DOCKER-USER]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.157298644+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C DOCKER-USER -j RETURN]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.174001382+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -t filter -C FORWARD -j DOCKER-USER]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.188689266+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -D FORWARD -j DOCKER-USER]&rdquo;
Nov 20 19:57:59 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:57:59.208030003+08:00&rdquo; level=debug msg=&ldquo;/usr/sbin/iptables, [&ndash;wait -I FORWARD -j DOCKER-USER]&rdquo;
Nov 20 19:58:17 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:58:17.326531605+08:00&rdquo; level=info msg=&ldquo;Loading containers: done.&rdquo;
Nov 20 19:58:17 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:58:17.649466743+08:00&rdquo; level=info msg=&ldquo;Daemon has completed initialization&rdquo;
Nov 20 19:58:17 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:58:17.649603664+08:00&rdquo; level=info msg=&ldquo;Docker daemon&rdquo; commit=cec0b72 graphdriver=overlay version=17.06.2-ce
Nov 20 19:58:17 localhost dockerd[29194]: time=&ldquo;2019-11-20T19:58:17.649854403+08:00&rdquo; level=debug msg=&ldquo;Registering routers&rdquo;
</blockcode></pre>
</details></p>

<p>通过日志，我们可以看到在启用<code>--ip-masq</code>这个配置的情况下，<code>dockerd</code>服务的日志会先删除，再重新生成上述两行防火墙规则。下面看下源码是如何处理这个规则的。</p>

<h3 id="查看源码">查看源码</h3>

<p>下载对应环境中17.06.2-ce的Docker代码，我们可以搜索<code>MASQUERADE</code>或者<code>POSTROUTING</code>关键字，可以发现在<code>libnetwork/drivers/bridge/setup_ip_tables.go</code>里是有相关设置的。</p>

<pre><code class="language-go">func setupIPTablesInternal(bridgeIface string, addr net.Addr, icc, ipmasq, hairpin, enable bool) error {

	var (
		address   = addr.String()
		natRule   = iptRule{table: iptables.Nat, chain: &quot;POSTROUTING&quot;, preArgs: []string{&quot;-t&quot;, &quot;nat&quot;}, args: []string{&quot;-s&quot;, address, &quot;!&quot;, &quot;-o&quot;, bridgeIface, &quot;-j&quot;, &quot;MASQUERADE&quot;}}
		hpNatRule = iptRule{table: iptables.Nat, chain: &quot;POSTROUTING&quot;, preArgs: []string{&quot;-t&quot;, &quot;nat&quot;}, args: []string{&quot;-m&quot;, &quot;addrtype&quot;, &quot;--src-type&quot;, &quot;LOCAL&quot;, &quot;-o&quot;, bridgeIface, &quot;-j&quot;, &quot;MASQUERADE&quot;}}
		skipDNAT  = iptRule{table: iptables.Nat, chain: DockerChain, preArgs: []string{&quot;-t&quot;, &quot;nat&quot;}, args: []string{&quot;-i&quot;, bridgeIface, &quot;-j&quot;, &quot;RETURN&quot;}}
		outRule   = iptRule{table: iptables.Filter, chain: &quot;FORWARD&quot;, args: []string{&quot;-i&quot;, bridgeIface, &quot;!&quot;, &quot;-o&quot;, bridgeIface, &quot;-j&quot;, &quot;ACCEPT&quot;}}
	)

	// Set NAT.
	if ipmasq {
		if err := programChainRule(natRule, &quot;NAT&quot;, enable); err != nil {
			return err
		}
    }
    ...
}
</code></pre>

<p>可以看到只有上述<code>ipmasq</code>为<code>true</code>的时候，该<code>POSTROUTING</code>的规则才会被创建。而我们继续向上追溯，<code>setupIPTablesInternal</code>这个函数是在<code>setup_ip_tables.go</code>中<code>setupIPTables</code>进行调用，该函数如下：</p>

<pre><code class="language-go">// setup_ip_tables.go
func (n *bridgeNetwork) setupIPTables(config *networkConfiguration, i *bridgeInterface) error {
	var err error

	d := n.driver
	d.Lock()
	driverConfig := d.config
	d.Unlock()

	// Sanity check.
	if driverConfig.EnableIPTables == false {
		return errors.New(&quot;Cannot program chains, EnableIPTable is disabled&quot;)
    }
    ...

	if config.Internal {
		...
	} else {
		if err = setupIPTablesInternal(config.BridgeName, maskedAddrv4, config.EnableICC, config.EnableIPMasquerade, hairpinMode, true); err != nil {
			return fmt.Errorf(&quot;Failed to Setup IP tables: %s&quot;, err.Error())
		}
		n.registerIptCleanFunc(func() error {
			return setupIPTablesInternal(config.BridgeName, maskedAddrv4, config.EnableICC, config.EnableIPMasquerade, hairpinMode, false)
		})
	}

	return nil
}
</code></pre>

<p>我们看到<code>ipmasq</code>对应的是<code>config.EnableIPMasquerade</code>，我们继续查找<code>config.EnableIPMasquerade</code>引用的地方，发现针对该配置的设置是在初始化bridge的时候进行的。</p>

<p>接下来我们看下从dockerd启动到初始化bridge及网络的这个过程中，相关<code>ipmasq</code>的处理。</p>

<h3 id="具体的启动实现流程">具体的启动实现流程</h3>

<p>首先dockerd读取命令行参数并调用<code>daemonCli.start(opts)</code>，该函数先读取<code>/etc/docker/daemon.json</code>的文件，并与命令行参数进行比对及配置合并，然后会执行<code>NewDaemon</code>函数进行daemon的初始化，主要的daemon的逻辑在这个函数完成。</p>

<h5 id="newdaemon首先执行verfiydaemonsettings函数进行参数的校验处理">NewDaemon首先执行verfiyDaemonSettings函数进行参数的校验处理</h5>

<pre><code class="language-go">func verifyDaemonSettings(conf *config.Config) error {
	...
	// 如果iptables为false，即使ip-masq为true，该ip-masq仍然失效，这个和上面官方文档的说明是一致的。
	if !conf.BridgeConfig.EnableIPTables &amp;&amp; conf.BridgeConfig.EnableIPMasq {
		conf.BridgeConfig.EnableIPMasq = false
	}
	...
	return nil
}
</code></pre>

<h5 id="执行数据恢复">执行数据恢复</h5>

<p>配置处理好后，会执行日志驱动、线程数等设置，并且根据数据目录（<code>/var/lib/docker</code>）初始化相应的组件的存储信息，以上执行完后，会执行数据恢复的步骤，该步骤是为了把之前本机的容器网络、容器配置好并启动，函数为<code>d.restore()</code>，下面进入该函数。</p>

<pre><code class="language-go">// daemon/daemon.go
func (daemon *Daemon) restore() error {
	var (
		currentDriver = daemon.GraphDriverName()
		containers    = make(map[string]*container.Container)
	)

	logrus.Info(&quot;Loading containers: start.&quot;)

	dir, err := ioutil.ReadDir(daemon.repository)
	if err != nil {
		return err
	}

	for _, v := range dir {
		id := v.Name()
        // 读取`/var/lib/docker/containers`中所有文件目录，获取到所有的容器信息，加载到内存中，
        // 每次加载完一个容器，会打印`Loaded container `字样的日志
	}

	removeContainers := make(map[string]*container.Container)
	restartContainers := make(map[*container.Container]chan struct{})
	activeSandboxes := make(map[string]interface{})
	for id, c := range containers {
        // 查看上述加载的容器，并把老版本的容器进行配置或volumes的迁移，用于兼容老版本启动的容器
        ...
	}

	var wg sync.WaitGroup
	var mapLock sync.Mutex
	for _, c := range containers {
		wg.Add(1)
		go func(c *container.Container) {
			defer wg.Done()
            //启动多协程，对状态为`Running`和`Paused`的容器进行不同的处理，处理包括：mount、remove等操作
            ...
		}(c)
	}
    wg.Wait()
    // 初始化网络
	daemon.netController, err = daemon.initNetworkController(daemon.configStore, activeSandboxes)
	if err != nil {
		return fmt.Errorf(&quot;Error initializing network controller: %v&quot;, err)
	}
    ...
	logrus.Info(&quot;Loading containers: done.&quot;)

	return nil
}
</code></pre>

<h5 id="进入initnetworkcontroller方法-查看具体的实现">进入initNetworkController方法，查看具体的实现。</h5>

<pre><code class="language-go">// daemon/daemon_unix.go
func (daemon *Daemon) initNetworkController(config *config.Config, activeSandboxes map[string]interface{}) (libnetwork.NetworkController, error) {
    // 处理network的配置，把默认的bridge的网络插件添加到配置中
	netOptions, err := daemon.networkOptions(config, daemon.PluginStore, activeSandboxes)
	if err != nil {
		return nil, err
	}

    // 创建网络的控制器
    // 1. 默认把`/var/lib/docker/network/files/local-kv.db`作为网络的数据库存储容器网络相关信息。
    // 2. 初始化docker支持的所有网络类型，如：bridge、host、none等。
    // 3. 清理之前docker创建的iptables规则，并处理FORWARD规则。
    // 该部分的实现内容可以参考`libnetwork.New(netOptions...)`的实现
	controller, err := libnetwork.New(netOptions...)
	if err != nil {
		return nil, fmt.Errorf(&quot;error obtaining controller instance: %v&quot;, err)
	}

    // Initialize default network on &quot;null&quot;
    ...
    // Initialize default network on &quot;host&quot;
    ...
	// 清理无用的bridge网络
	if n, err := controller.NetworkByName(&quot;bridge&quot;); err == nil {
		if err = n.Delete(); err != nil {
			return nil, fmt.Errorf(&quot;could not delete the default bridge network: %v&quot;, err)
		}
	}

	if !config.DisableBridge {
		// Initialize default driver &quot;bridge&quot;
		if err := initBridgeDriver(controller, config); err != nil {
			return nil, err
		}
	} else {
		removeDefaultBridgeInterface()
	}

	return controller, nil
}

func initBridgeDriver(controller libnetwork.NetworkController, config *config.Config) error {
	bridgeName := bridge.DefaultBridgeName
	if config.BridgeConfig.Iface != &quot;&quot; {
		bridgeName = config.BridgeConfig.Iface
	}
	netOption := map[string]string{
		bridge.BridgeName:         bridgeName,
		bridge.DefaultBridge:      strconv.FormatBool(true),
        netlabel.DriverMTU:        strconv.Itoa(config.Mtu),
        // config.BridgeConfig.EnableIPMasq 这里对应了1中的verifyDaemonSettings的校验函数。
		bridge.EnableIPMasquerade: strconv.FormatBool(config.BridgeConfig.EnableIPMasq),
		bridge.EnableICC:          strconv.FormatBool(config.BridgeConfig.InterContainerCommunication),
	}

	// --ip processing
	if config.BridgeConfig.DefaultIP != nil {
		netOption[bridge.DefaultBindingIP] = config.BridgeConfig.DefaultIP.String()
    }
    ...
    // NewNetwork这个方法是初始化bridge，进入该函数
	// Initialize default network on &quot;bridge&quot; with the same name
	_, err = controller.NewNetwork(&quot;bridge&quot;, &quot;bridge&quot;, &quot;&quot;,
		libnetwork.NetworkOptionEnableIPv6(config.BridgeConfig.EnableIPv6),
		libnetwork.NetworkOptionDriverOpts(netOption),
		libnetwork.NetworkOptionIpam(&quot;default&quot;, &quot;&quot;, v4Conf, v6Conf, nil),
		libnetwork.NetworkOptionDeferIPv6Alloc(deferIPv6Alloc))
	if err != nil {
		return fmt.Errorf(&quot;Error creating default \&quot;bridge\&quot; network: %v&quot;, err)
	}
	return nil
}
</code></pre>

<p>NewNetwork这个方法是初始化bridge，进入该函数，发现调用<code>github.com/docker/libnetwork/drivers/bridge/bridge.go</code>中的<code>createNetwork</code>方法，进入到方法中，我们看到这个<code>createNetwork</code>方法最终调用了我们在一开始看到的<code>setupIPTables</code>这个方法进行iptables规则的处理。</p>

<pre><code class="language-go">// github.com/docker/libnetwork/drivers/bridge/bridge.go
func (d *driver) createNetwork(config *networkConfiguration) error {

    ...
    network := &amp;bridgeNetwork{
		id:         config.ID,
		endpoints:  make(map[string]*bridgeEndpoint),
		config:     config,
		portMapper: portmapper.New(d.config.UserlandProxyPath),
		driver:     d,
	}
    ...
	// Conditionally queue setup steps depending on configuration values.
	for _, step := range []struct {
		Condition bool
		Fn        setupStep
	}{
		...
		// Setup IPTables.
		{d.config.EnableIPTables, network.setupIPTables},
        ...
	} {
		if step.Condition {
			bridgeSetup.queueStep(step.Fn)
		}
	}

	return nil
}
</code></pre>

<p>到这里，我们就了解了docker是如何处理<code>--ip-masq</code>这个参数并如何根据这个参数进行iptables规则的设置。</p>

<h5 id="libnetwork-new-netoptions-的实现">libnetwork.New(netOptions&hellip;)的实现</h5>

<pre><code class="language-go">// github.com/docker/libnetwork/controller.go
// New creates a new instance of network controller.
func New(cfgOptions ...config.Option) (NetworkController, error) {
	c := &amp;controller{
		id:              stringid.GenerateRandomID(),
		cfg:             config.ParseConfigOptions(cfgOptions...),
		sandboxes:       sandboxTable{},
		svcRecords:      make(map[string]svcInfo),
		serviceBindings: make(map[serviceKey]*service),
		agentInitDone:   make(chan struct{}),
		networkLocker:   locker.New(),
	}

    // 创建读取网络数据库的client
	if err := c.initStores(); err != nil {
		return nil, err
	}

	drvRegistry, err := drvregistry.New(c.getStore(datastore.LocalScope), c.getStore(datastore.GlobalScope), c.RegisterDriver, nil, c.cfg.PluginGetter)
	if err != nil {
		return nil, err
	}

    // 添加并初始化所有网络类型，getInitializers的函数如下，可以看到这些是docker支持的网络类型。
    // 我们主要关注在bridge的类型，即bridge.Init这个方法。
    /*
        func getInitializers(experimental bool) []initializer {
            in := []initializer{
                {bridge.Init, &quot;bridge&quot;},
                {host.Init, &quot;host&quot;},
                {macvlan.Init, &quot;macvlan&quot;},
                {null.Init, &quot;null&quot;},
                {remote.Init, &quot;remote&quot;},
                {overlay.Init, &quot;overlay&quot;},
            }

            if experimental {
                in = append(in, additionalDrivers()...)
            }
            return in
        }
    */
	for _, i := range getInitializers(c.cfg.Daemon.Experimental) {
		var dcfg map[string]interface{}

		// External plugins don't need config passed through daemon. They can
		// bootstrap themselves
		if i.ntype != &quot;remote&quot; {
			dcfg = c.makeDriverConfig(i.ntype)
		}

		if err := drvRegistry.AddDriver(i.ntype, i.fn, dcfg); err != nil {
			return nil, err
		}
    }
    ...

	return c, nil
}
</code></pre>

<pre><code class="language-go">// bridge.Init方法的实现。
// Init registers a new instance of bridge driver
func Init(dc driverapi.DriverCallback, config map[string]interface{}) error {
	d := newDriver()
	if err := d.configure(config); err != nil {
		return err
	}

	c := driverapi.Capability{
		DataScope:         datastore.LocalScope,
		ConnectivityScope: datastore.LocalScope,
	}
	return dc.RegisterDriver(networkType, d, c)
}

func (d *driver) configure(option map[string]interface{}) error {
	var (
		config         *configuration
		err            error
		natChain       *iptables.ChainInfo
		filterChain    *iptables.ChainInfo
		isolationChain *iptables.ChainInfo
    )
    ...

	if config.EnableIPTables {
		if _, err := os.Stat(&quot;/proc/sys/net/bridge&quot;); err != nil {
			if out, err := exec.Command(&quot;modprobe&quot;, &quot;-va&quot;, &quot;bridge&quot;, &quot;br_netfilter&quot;).CombinedOutput(); err != nil {
				logrus.Warnf(&quot;Running modprobe bridge br_netfilter failed with message: %s, error: %v&quot;, out, err)
			}
        }
        // 清理之前docker相关的iptables规则，在前面章节的日志可以看到有删除iptables规则
		removeIPChains()
		natChain, filterChain, isolationChain, err = setupIPChains(config)
		if err != nil {
			return err
		}
		// Make sure on firewall reload, first thing being re-played is chains creation
		iptables.OnReloaded(func() { logrus.Debugf(&quot;Recreating iptables chains on firewall reload&quot;); setupIPChains(config) })
	}

    // 这里是处理FORWARD规则的地方，会去读取/proc/sys/net/ipv4/ip_forward中的值进行处理
	if config.EnableIPForwarding {
		err = setupIPForwarding(config.EnableIPTables)
		if err != nil {
			logrus.Warn(err)
			return err
		}
    }
    ...

	return nil
}
</code></pre>

<h3 id="数据存储在本地db文件中的内容">数据存储在本地db文件中的内容</h3>

<p>docker默认使用boltdb来存储网络相关的配置信息，那么我们看下在这个db文件中到底保存的数据格式是什么，对于我们以后看docker的一些源码实现或者自身组件的实现可能会有帮助。</p>

<p>我们通过代码，可以读取存储在本机的docker网络配置，我们读取了Key为<code>docker/network/v1.0/bridge</code>的值，该key为docker的默认bridge的信息，信息格式如下：</p>

<pre><code class="language-json">{
    &quot;BridgeIfaceCreator&quot;: 2,
    &quot;Internal&quot;: false,
    &quot;DefaultBridge&quot;: true,
    &quot;EnableICC&quot;: true,
    &quot;EnableIPv6&quot;: false,
    &quot;Mtu&quot;: 1500,
    &quot;DefaultGatewayIPv6&quot;: &quot;&lt;nil&gt;&quot;,
    &quot;EnableIPMasquerade&quot;: true,
    &quot;DefaultGatewayIPv4&quot;: &quot;&lt;nil&gt;&quot;,
    &quot;AddressIPv4&quot;: &quot;172.17.0.1/16&quot;,
    &quot;ContainerIfacePrefix&quot;: &quot;&quot;,
    &quot;ID&quot;: &quot;6ce3c0c4d5c392d732a06a7ea9d6293bf04201056d563f7a6ad5ef9d8b3822db&quot;,
    &quot;BridgeName&quot;: &quot;docker0&quot;,
    &quot;DefaultBindingIP&quot;: &quot;0.0.0.0&quot;
}
</code></pre>

<p>可以看到<code>EnableIPMasquerade</code>我们设置的<code>true</code>，从而使得前文所说的<code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</code>规则被创建。</p>

<pre><code class="language-go">// 读取boltdb的代码示例
package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;time&quot;

	&quot;github.com/docker/libkv&quot;
	&quot;github.com/docker/libkv/store&quot;
	&quot;github.com/docker/libkv/store/boltdb&quot;
)

func init() {
	// Register boltdb store to libkv
	boltdb.Register()
}

func main() {
	client := &quot;./local-kv.db&quot;

	// Initialize a new store
	kv, err := libkv.NewStore(
		store.BOLTDB,
		[]string{client},
		&amp;store.Config{
			Bucket:            &quot;libnetwork&quot;,
			ConnectionTimeout: 10 * time.Second,
		},
	)
	if err != nil {
		log.Fatalf(&quot;Cannot create store: %v&quot;, err)
	}

	pair, err := kv.List(&quot;docker/network/v1.0/bridge&quot;)
	for _, p := range pair {
		fmt.Println(p.Key)
		fmt.Println(string(p.Value))
	}
}
</code></pre>

<h2 id="总结">总结</h2>

<p>实现流程如下：</p>

<ol>
<li><code>dockerd</code>首先根据配置文件和命令行参数获取<code>--iptables</code>和<code>--ip-masq</code>的值</li>
<li>进行参数校验，校验后决定<code>ip-masq</code>是否启用</li>
<li>在<code>dockerd</code>初始化bridge网络的时候，先清理旧的iptables规则，然后依次添加新的iptables规则</li>
<li>如果启用<code>ip-masq</code>，那么创建<code>POSTROUTING</code>的规则。</li>
</ol>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">标签</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://pytimer.github.io/tags/iptables/">iptables</a>

                  </div>
                
              
            
            
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://pytimer.github.io/2019/12/kubernetes-dashboard-installation/" data-tooltip="Kubernetes Dashboard Installation">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://pytimer.github.io/2019/10/go%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" data-tooltip="Go开发规范">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2020 <a href="https://github.com/pytimer">pytimer</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
        
  <div class="post-actions-wrap">
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://pytimer.github.io/2019/12/kubernetes-dashboard-installation/" data-tooltip="Kubernetes Dashboard Installation">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">下一篇</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://pytimer.github.io/2019/10/go%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/" data-tooltip="Go开发规范">
              
                  <span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
              <i class="fa fa-facebook-official"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
        
          <li class="post-action hide-xs">
            <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        
      
      
        <li class="post-action">
          <a class="post-action-btn btn btn--default" href="#disqus_thread">
            <i class="fa fa-comment-o"></i>
          </a>
        </li>
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  </div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="4">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fpytimer.github.io%2F2019%2F11%2Fdocker%25E5%25AE%25B9%25E5%2599%25A8%25E6%2597%25A0%25E6%25B3%2595%25E8%25BF%259E%25E6%258E%25A5%25E5%25A4%2596%25E9%2583%25A8%25E7%25BD%2591%25E7%25BB%259C%25E5%258E%259F%25E5%259B%25A0%25E6%258E%2592%25E6%259F%25A5%2F">
          <i class="fa fa-facebook-official"></i><span>分享到 Facebook</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https%3A%2F%2Fpytimer.github.io%2F2019%2F11%2Fdocker%25E5%25AE%25B9%25E5%2599%25A8%25E6%2597%25A0%25E6%25B3%2595%25E8%25BF%259E%25E6%258E%25A5%25E5%25A4%2596%25E9%2583%25A8%25E7%25BD%2591%25E7%25BB%259C%25E5%258E%259F%25E5%259B%25A0%25E6%258E%2592%25E6%259F%25A5%2F">
          <i class="fa fa-twitter"></i><span>分享到 Twitter</span>
        </a>
      </li>
    
      <li class="share-option">
        <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3A%2F%2Fpytimer.github.io%2F2019%2F11%2Fdocker%25E5%25AE%25B9%25E5%2599%25A8%25E6%2597%25A0%25E6%25B3%2595%25E8%25BF%259E%25E6%258E%25A5%25E5%25A4%2596%25E9%2583%25A8%25E7%25BD%2591%25E7%25BB%259C%25E5%258E%259F%25E5%259B%25A0%25E6%258E%2592%25E6%259F%25A5%2F">
          <i class="fa fa-google-plus"></i><span>分享到 Google&#43;</span>
        </a>
      </li>
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://raw.githubusercontent.com/pytimer/pytimer.github.io/master/gopher.png" alt="作者的图片" />
    
    <h4 id="about-card-name">Pytimer</h4>
    
      <div id="about-card-bio">Software Develper, <strong>Like Go and Cloud</strong></div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Golang developer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        China
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="搜索" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2020/07/%E5%9C%A8windows%E4%B8%8A%E4%BD%BF%E7%94%A8kubectl%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4/">
                <h3 class="media-heading">在Windows上使用Kubectl连接集群</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2020
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">平时都在Linux上搭建并操作Kubernetes集群，但是有时候会使用Windows来进行开发或者日常工作，这个时候如果在登录某台Linux主机，通过kubectl命令行操作集群就显得不是很方便，Kubernetes本身也是提供了Windows的命令行，因此在Windows上安装并配置kubectl，用于操作远端的Kubernetes集群。下面就是相关步骤。
下载Windows版本kubectl 可以按照官方文档Install kubectl on Windows来下载Windows版本的kubectl命令行。
因集群为v1.17.2版本，因此这里直接下载指定版本的kubectl.exe。
curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.17.2/bin/windows/amd64/kubectl.exe
下载好后，配置Windows的PATH，在该环境变量值后增加F:\k8s\bin(该路径为kubectl.exe的目录)。
配置好后，打开Git Bash或其他的工具，输入kubectl.exe version --client，可以看到对应的kubectl版本。到这里kubectl就安装好了。下面需要配置kubectl来连接远端Kubernetes集群。
$ kubectl.exe version --client Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;17&quot;, GitVersion:&quot;v1.17.2&quot;, GitCommit:&quot;59603c6e503c87169aea6106f57b9f242f64df89&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-01-18T23:30:10Z&quot;, GoVersion:&quot;go1.13.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;windows/amd64&quot;}  配置kubectl kubectl需要使用kubeconfig来连接远端集群，通常有三种方式来指定kubeconfig。
 ~/.kube/config，默认kubectl会使用该目录。 KUBECONFIG，使用该环境变量的文件。 --kubeconfig，每次执行命令指定kubeconfig文件。  这里采用第2种方式。因此在Windows上配置一个环境变量KUBECONFIG。设置KUBECONFIG=F:\k8s\bin\kubeconfig。
重新打开Git Bash，执行kubectl.exe get nodes，可以看到连接到了远端的Kubernetes集群。
$ kubectl.exe get nodes NAME STATUS ROLES AGE VERSION meta-k8s-234 Ready master 29m v1.17.2 meta-k8s-235 Ready &lt;none&gt; 28m v1.17.2 meta-k8s-236 Ready &lt;none&gt; 28m v1.17.2 meta-k8s-237 Ready &lt;none&gt; 28m v1.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/12/kubernetes-dashboard-installation/">
                <h3 class="media-heading">Kubernetes Dashboard Installation</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Dec 12, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Dashboard为Kubernetes官方的一个webui，集合了所有命令行可以操作的资源，可以根据浏览器的语言自动进行语言的识别。通过webui，我们可以更直观的看到Kubernetes集群的运行情况。不过在安装Dashboard的过程中有一些坑，因此在这里整理成文档以便在今后方便查阅。
安装 Dashboard的安装相对还是简单的，参考官方的github就可以。
 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml
 不过在这中间有一个坑，那就是Dashboard的webui默认是自动生成证书的，由于时间和名称的问题，会导致Chrome和IE等浏览器无法打开界面，这里需要我们自己制作证书处理。
开启NodePort kind: Service apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kube-system spec: ports: - port: 443 targetPort: 8443 nodePort: 30003 selector: k8s-app: kubernetes-dashboard type: NodePort  使用kubectl apply的命令将该service应用在Kubernetes集群中，可以看到该service已经生效。
[root@k8s ~]# kubectl get svc -n kube-system kubernetes-dashboard NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes-dashboard NodePort 10.106.67.12 &lt;none&gt; 443:30003/TCP 40m  通过浏览器访问Dashboard，我们发现无法访问界面，会有类似x.x.x.x通常会使用加密技术来保护您的信息，Google Chrome此次尝试连接到x.x.x.x时，此网站发回了异常的错误凭据。...的字样，更换IE、360浏览器均无法访问，在机器上使用curl -k https://x.x.x.x:30003/命令测试，是可以通的。
出现以上现象是因为Dashboard默认为webui生成的证书时间是无效的，时间是过期的，因此需要解决下该问题，以通过浏览器来访问。
解决证书过期问题 [root@k8s ~]# openssl genrsa -out dashboard.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/11/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5/">
                <h3 class="media-heading">Docker容器无法连接外部网络原因排查</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Docker是当前最常用的容器运行时引擎，在使用Kubernetes的过程中，我们使用Docker来负责底层的容器的启动、停止。在用户新安装Docker后的使用过程中，发现通过docker run命令启动的容器，使用默认的bridge网络的情况下，容器无法连接到外部网络，针对这个现象进行排查。
缩小问题范围 使用 docker run -it --rm alpine:3.6 /bin/sh 启动一个容器，采用bridge网络，在容器内ping外部网络的IP，我们发现是无法ping通，该命令会hang住。退出该容器，再尝试使用host网络启动容器，docker run -it --rm --network=host alpine:3.6 /bin/sh，这次我们发现是可以ping通外部网络的，说明是docker的默认bridge网络有问题，缩小范围。
容器使用bridge网络的情况下，在ping外部网络的情况下，如果发送的不是Docker启动创建的docker0的网桥，会进行SNAT，然后使用宿主机的网卡出去，那么怀疑是SNAT可能有问题，因此查看iptables中和Docker相关的规则。命令结果如下：
# iptables -t nat -nvL POSTROUTING Chain POSTROUTING (policy ACCEPT 845 packets, 57086 bytes) pkts bytes target prot opt in out source destination 1414 96107 POSTROUTING_direct all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES_SOURCE all -- * * 0.0.0.0/0 0.0.0.0/0 1414 96107 POSTROUTING_ZONES all -- * * 0.0.0.0/0 0.0.0.0/0  根据上面结果，我们发现缺少了一条-A POSTROUTING -s 172.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/10/go%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/">
                <h3 class="media-heading">Go开发规范</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Oct 10, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">代码规范 辅助工具 goimports goimports是Go官方提供的工具，能够为我们自动格式化Go语言代码并对引入的包进行管理，其中包括自动增删依赖包引用，将依赖包进行分类排序。
goimports等价于gofmt加依赖包的管理。
因此建议所有GO语言开发人员在开发时，使用goimports进行格式化，并在IDE中进行配置，保存时自动格式化。
在Goland中进行设置 golint golint是Go官方提供的静态检查工具，该工具的诟病在于可定制化不足，但是在Go的社区中，保证一致性的编程规范是有益的事情，因此该工具大多数用在基础库和框架项目中，上层业务应用可以选用golangci-lint这个工具进行静态检查。
建议所有Go语言开发人员在项目中加入golint或golangci-lint工具进行静态检查，甚至于对于基础库和框架来说，可以同时使用上述两个工具来进行检查。
自动化 无论是上述的格式化还是静态检查，我们都要在我们的CI流程中进行自动化的处理，从而减少代码审核人员的工作，将重心放在代码逻辑上。
Drone结合上述工具进行自动化的示例。
项目开发 目录结构 在项目开发中，Go官方并没有给出一个推荐的目录规划，而在社区中有一些常见的约定，具体的可以看golang-standards/project-layout ，我们也是建议采用该方式进行项目目录规划。
├── LICENSE ├── Makefile ├── README.md ├── api ├── assets ├── build ├── cmd ├── configs ├── deployments ├── docs ├── examples ├── githooks ├── init ├── internal ├── pkg ├── scripts ├── test ├── third_party ├── tools ├── vendor ├── web └── website  下面介绍常见并且重要的目录及文件。
README.md 该文件写明该项目的简介，功能说明等。
CONTRIBUTING.md 该文件说明其他开发人员如何合作开发该项目。
/pkg 该目录存放的是项目中可以被外部项目或者本项目使用的代码仓库，外部项目直接通过import即可引入该包代码。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/09/faq-%E4%BF%AE%E6%94%B9configmap%E5%90%8E%E4%BD%BF%E7%94%A8subpath%E7%9A%84pod%E5%BC%82%E5%B8%B8/">
                <h3 class="media-heading">[FAQ] 修改configmap后，使用subPath的Pod异常</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Pod状态异常，挂载configmap显示no such file or directory $ kubectl get pod -o wide test-7695dc7fb9-rjxlq 0/1 CrashLoopBackOff 13 17h 192.168.100.20 node1 &lt;none&gt;  CrashLoopBackOff状态需要查看pod的日志，通过kubectl logs可以查看到具体的错误信息。
$ kubectl logs -n test-7695dc7fb9-rjxlq container_linux.go:345: starting container process caused &quot;process_linux.go:430: container init caused \&quot;rootfs_linux.go:58: mounting \\\&quot;/var/lib/kubelet/pods/ed1b799a-d3a5-11e9-add6-0894ef725f6e/volume-subpaths/test-cm/app-conf/1\\\&quot; to rootfs \\\&quot;/var/lib/docker/overlay/23a69e27f79f84a14b50fbee1e4840836487f8c740423291c2f785da1e7a6820/merged\\\&quot; at \\\&quot;/var/lib/docker/overlay/23a69e27f79f84a14b50fbee1e4840836487f8c740423291c2f785da1e7a6820/merged/etc/app/app.conf\\\&quot; caused \\\&quot;no such file or directory\\\&quot;\&quot;&quot;  查看日志发现是挂载的configmap有问题。
猜测原因：该pod采用subPath的方式挂载configmap，怀疑是configmap修改后，未重建pod导致，因此会出现上述no such file or directory的错误。
排查问题 查看异常pod的uid，通过下述的命令我们可以看到当前pod在2019-09-10T08:35:21Z的时间创建，并且uid为ed1b799a-d3a5-11e9-add6-0894ef725f6e。
$ kubectl get pod test-7695dc7fb9-rjxlq -o json | jq .metadata { &quot;creationTimestamp&quot;: &quot;2019-09-10T08:35:21Z&quot;, &quot;generateName&quot;: &quot;test-7695dc7fb9-&quot;, &quot;labels&quot;: { &quot;application&quot;: &quot;test&quot;, &quot;pod-template-hash&quot;: &quot;3251873965&quot; }, &quot;name&quot;: &quot;test-7695dc7fb9-rjxlq&quot;, &quot;namespace&quot;: &quot;openstack&quot;, &quot;ownerReferences&quot;: [ { &quot;apiVersion&quot;: &quot;apps/v1&quot;, &quot;blockOwnerDeletion&quot;: true, &quot;controller&quot;: true, &quot;kind&quot;: &quot;ReplicaSet&quot;, &quot;name&quot;: &quot;test-7695dc7fb9&quot;, &quot;uid&quot;: &quot;ece58508-d3a5-11e9-add6-0894ef725f6e&quot; } ], &quot;resourceVersion&quot;: &quot;1762165&quot;, &quot;selfLink&quot;: &quot;/api/v1/namespaces/default/pods/test-7695dc7fb9-rjxlq&quot;, &quot;uid&quot;: &quot;ed1b799a-d3a5-11e9-add6-0894ef725f6e&quot; }  接下来就需要登录到pod所在的节点进行查看。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/06/mac%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8docker/">
                <h3 class="media-heading">Mac安装使用Docker</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jun 6, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Docker是目前最常用的容器引擎，在Mac上安装Docker。
安装、配置Docker Install Docker Desktop for Mac
按照官方文档直接下载Docker.img并双击安装即可，安装的过程中，需要输入当前用户的登录密码。
配置Docker 在Mac上，我们需要先注册Docker ID，进行登录才可以使用。因此我们需要先去https://cloud.docker.com注册自己的账号。
Dockerhub关联Github上的项目 关联Github账号 进入https://cloud.docker.com，登录自己的账号，然后点击账号的倒三角，看到Account Settings，点击进入设置页面，查看Linked Accounts选项卡，可以关联Github账号，关联好后会显示关联成功。
创建Repository 创建好Repository后，点击Builds，设置自动制作镜像的操作。</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/06/coredns%E7%AE%80%E4%BB%8B/">
                <h3 class="media-heading">Coredns简介</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jun 6, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">DNS Linux上通过/etc/resolv.conf文件可以配置DNS相关信息，该文件是resovler类库所使用的配置文件，每当通过域名访问其他主机时，该类库会将域名转换为对应的IP，然后才可以进行访问。
resolv.conf 配置 nameserver 该选项用来配置DNS服务器地址，可以指定多个DNS
domain 该选项用来指定本地的域名，没有配置search的情况下，search默认使用的为domain的值
search 用来指定多个域名，用空格分隔。当访问的域名无法被DNS服务器解析时，resolver会将该域名后加上search指定的值，重新请求DNS，直到被正确解析或者列表循环结束。
nslookup 默认的超时时间为15s左右。
没有配置nameserver 在没有配置任何DNS的情况下，解析域名失败，返回如下错误：
$ nslookup baidu.com ;; connection timed out; no servers could be reached  配置nameserver $ cat /etc/resolv.conf nameserver 8.8.8.8  $ nslookup baidu.com Server: 8.8.8.8 Address: 8.8.8.8#53 Non-authoritative answer: Name: baidu.com Address: x.x.x.x Name: baidu.com Address: y.y.y.y  如果没有解析域名成功会有如下信息：
$ nslookup aaa.bbb.ccc Server: 8.8.8.8 Address: 8.8.8.8#53 ** server can't find aaa.bbb.ccc: NXDOMAIN  DNS常见记录类型  A：指定域名对应的IP地址</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/05/change-etcd-cluster-member-ip/">
                <h3 class="media-heading">Change Etcd cluster member ip</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">背景 Etcd是用于共享配置和服务发现的分布式、满足一致性的KV系统，受到Zookeeper启发，该项目是由CoreOS公司发起。目前在各种云环境中应用广泛，几个比较流行的云项目都采用了Etcd，如CloudFoundry、Kubernetes、Docker。Etcd采用Raft协议进行主节点的选举，并把相应的成员信息存储在各成员的db中。更多关于Etcd的详细介绍，可以在网上或者官方看到，这里不进行相关描述。
由于Kubernetes采用Etcd作为后端数据存储，如果Etcd出现问题，会导致整个Kubernetes集群的数据不一致，严重的甚至会导致集群不可用，因此需要掌握Etcd集群的常见问题解决方式，以便在该组件出现故障的时候，可以及时修复，从而保证Kubernetes集群的正常可用，不影响用户的使用。
如果Kubernetes集群部署完成后，更新整个集群所有节点的IP地址，当前Kubernetes的控制节点和Etcd成员节点在同一主机上运行，这也意味着如果修改Kubernetes控制节点的IP地址，需要对Etcd集群进行操作，以便Etcd集群可以使用新的IP地址进行通信。因此本文档重点介绍Etcd集群成员变更的两种方式。
成员变更解决方式 Etcd集群本身满足(n/2)+1的成员容忍性。下面为集群大小对应的可容忍的异常成员数量。
   集群大小 Majority 容忍数量     1 1 0   2 2 0   3 2 1   4 3 1   5 3 2   6 4 2   7 4 3   8 5 3   9 5 4    目前我们的Kubernetes集群采用大多数是3节点的Etcd集群，因此允许一个节点失联。
下面详细描述下如何进行集群成员IP变更，因为我们的Etcd集群运行在容器中，采用Static Pod的方式由Kubelet进行管理，所以如果Etcd集群部署形态并非容器的话，请根据实际情况进行相应调整，关于etcdctl的操作是一致的，没有区别。
我们仍然使用下面的三节点集群，所有节点IP地址如下：
   成员名称 旧IP 新IP     master1 192.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/05/%E9%A2%84%E7%95%99%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90/">
                <h3 class="media-heading">预留计算资源</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  May 5, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">Kubernetes Node Allocatable 表示整个集群当前节点pod可用的计算资源量，该配置可以保证调度器不会超额申请计算资源，目前支持CPU,memory,storage这几个参数。
Node Capacity --------------------------- | kube-reserved | |-------------------------| | system-reserved | |-------------------------| | eviction-threshold | |-------------------------| | | | allocatable | | (available for pods) | | | | | ---------------------------  https://k8smeetup.github.io/docs/tasks/administer-cluster/out-of-resource/#eviction-policy https://yq.aliyun.com/articles/604524 https://github.com/rootsongjc/qa/issues/3 https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#general-guidelines https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/ https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/node-allocatable.md#recommended-cgroups-setup https://github.com/rancher/rancher/issues/17177 https://github.com/kubernetes/kubernetes/blob/v1.11.6/pkg/kubelet/cm/cgroup_manager_linux.go#L259 http://www.kbase101.com/question/18764.html https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/7/html/resource_management_guide/chap-using_control_groups#sec-Creating_Cgroups https://k8smeetup.github.io/docs/tasks/administer-cluster/reserve-compute-resources/ https://godoc.org/k8s.io/kubernetes/pkg/kubelet/apis/config#KubeletConfiguration</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://pytimer.github.io/2019/04/interface/">
                <h3 class="media-heading">Interface</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Apr 4, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather">检测struct类型是否实现了某个接口 package main import &quot;fmt&quot; type Resource interface { GetName() string Restart() } type Pod struct { Name string RestartNumber int } func (p Pod) GetName() string { return p.Name } func (p *Pod) Restart() { p.RestartNumber += 1 } func main() { // 会出现如下的错误: cannot use Pod literal (type Pod) as type Resource in assignment: Pod does not implement Resource (Restart method has pointer receiver) var _ Resource = Pod{} }  因此如果我们想要检测一个类型是否实现了指定的接口，可以通过var _ io.</div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         32 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://pytimer.github.io/images/cover.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://pytimer.github.io/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/pytimer.github.io\/2019\/11\/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5\/';
          
            this.page.identifier = '\/2019\/11\/docker%E5%AE%B9%E5%99%A8%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%A4%96%E9%83%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E5%9B%A0%E6%8E%92%E6%9F%A5\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'hugo-tranquilpeak-theme';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  



    
  </body>
</html>

